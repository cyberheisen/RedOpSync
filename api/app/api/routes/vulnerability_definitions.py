from uuid import UUID
import os
import uuid as uuid_mod
import shutil

from fastapi import APIRouter, Depends, HTTPException, Query, UploadFile, File
from sqlalchemy.orm import Session, joinedload

from fastapi import status

from app.core.deps import get_current_user
from app.core.config import settings
from app.db.session import get_db
from app.models.models import (
    VulnerabilityDefinition,
    VulnerabilityInstance,
    VulnerabilitySubnetAssociation,
    VulnerabilityAttachment,
    Host,
    Subnet,
    User,
)
from app.schemas.vulnerability_definition import (
    VulnerabilityDefinitionCreate,
    VulnerabilityDefinitionUpdate,
    VulnerabilityDefinitionRead,
    VulnerabilityDefinitionWithInstances,
    AffectedHostsUpdate,
    AffectedSubnetsUpdate,
)
from app.schemas.vulnerability_attachment import VulnerabilityAttachmentRead
from app.services.lock import require_lock
from app.services.vuln_affected import get_affected_host_ids
from app.services.audit import log_audit

router = APIRouter()


def _vuln_def_to_response(db: Session, d: VulnerabilityDefinition) -> VulnerabilityDefinitionWithInstances:
    affected = get_affected_host_ids(db, d)
    subnet_ids = [
        a.subnet_id
        for a in db.query(VulnerabilitySubnetAssociation)
        .filter(VulnerabilitySubnetAssociation.vulnerability_definition_id == d.id)
        .all()
    ]
    instances = db.query(VulnerabilityInstance).filter(VulnerabilityInstance.vulnerability_definition_id == d.id).all()
    return VulnerabilityDefinitionWithInstances(
        id=d.id,
        project_id=d.project_id,
        title=d.title,
        description_md=d.description_md,
        evidence_md=d.evidence_md,
        severity=d.severity,
        cvss_score=d.cvss_score,
        cve_ids=d.cve_ids or [],
        discovered_by=d.discovered_by,
        created_at=d.created_at,
        updated_at=d.updated_at,
        instance_count=len(instances),
        affected_host_ids=affected,
        affected_subnet_ids=subnet_ids,
    )


@router.get("", response_model=list[VulnerabilityDefinitionWithInstances])
def list_vulnerability_definitions(
    project_id: UUID = Query(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    q = db.query(VulnerabilityDefinition).filter(VulnerabilityDefinition.project_id == project_id)
    defs = q.order_by(VulnerabilityDefinition.created_at.desc()).all()
    return [_vuln_def_to_response(db, d) for d in defs]


@router.get("/{def_id}", response_model=VulnerabilityDefinitionWithInstances)
def get_vulnerability_definition(
    def_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    d = db.query(VulnerabilityDefinition).filter(VulnerabilityDefinition.id == def_id).first()
    if not d:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    return _vuln_def_to_response(db, d)


@router.post("", response_model=VulnerabilityDefinitionRead, status_code=201)
def create_vulnerability_definition(
    body: VulnerabilityDefinitionCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    host = db.query(Host).filter(Host.id == body.host_id, Host.project_id == body.project_id).first()
    if not host:
        raise HTTPException(status_code=404, detail="Host not found")
    defn = VulnerabilityDefinition(
        project_id=body.project_id,
        title=body.title,
        description_md=body.description_md,
        evidence_md=body.evidence_md,
        severity=body.severity or "Medium",
        cvss_score=body.cvss_score,
        cve_ids=body.cve_ids or [],
        discovered_by="manual",
    )
    db.add(defn)
    db.flush()
    instance = VulnerabilityInstance(
        project_id=body.project_id,
        vulnerability_definition_id=defn.id,
        host_id=body.host_id,
        port_id=body.port_id,
    )
    db.add(instance)
    for sid in body.subnet_ids or []:
        sub = db.query(Subnet).filter(Subnet.id == sid, Subnet.project_id == body.project_id).first()
        if sub:
            db.add(VulnerabilitySubnetAssociation(
                vulnerability_definition_id=defn.id,
                subnet_id=sid,
            ))
            log_audit(db, project_id=body.project_id, user_id=current_user.id,
                      action_type="vulnerability_applied_to_subnet",
                      record_type="vulnerability_definition", record_id=defn.id,
                      after_json={"subnet_id": str(sid)})
    db.commit()
    db.refresh(defn)
    return defn


@router.patch("/{def_id}", response_model=VulnerabilityDefinitionRead)
def update_vulnerability_definition(
    def_id: UUID,
    body: VulnerabilityDefinitionUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    defn = db.query(VulnerabilityDefinition).filter(VulnerabilityDefinition.id == def_id).first()
    if not defn:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    try:
        require_lock(db, defn.project_id, "vulnerability_definition", def_id, current_user)
    except PermissionError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    data = body.model_dump(exclude_unset=True)
    subnet_ids = data.pop("subnet_ids", None)
    for k, v in data.items():
        setattr(defn, k, v)
    if subnet_ids is not None:
        db.query(VulnerabilitySubnetAssociation).filter(
            VulnerabilitySubnetAssociation.vulnerability_definition_id == def_id
        ).delete()
        for sid in subnet_ids:
            sub = db.query(Subnet).filter(Subnet.id == sid, Subnet.project_id == defn.project_id).first()
            if sub:
                db.add(VulnerabilitySubnetAssociation(
                    vulnerability_definition_id=def_id,
                    subnet_id=sid,
                ))
                log_audit(db, project_id=defn.project_id, user_id=current_user.id,
                          action_type="vulnerability_applied_to_subnet",
                          record_type="vulnerability_definition", record_id=def_id,
                          after_json={"subnet_id": str(sid)})
    db.commit()
    db.refresh(defn)
    return defn


@router.patch("/{def_id}/affected-hosts", response_model=VulnerabilityDefinitionWithInstances)
def update_affected_hosts(
    def_id: UUID,
    body: AffectedHostsUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    defn = db.query(VulnerabilityDefinition).filter(VulnerabilityDefinition.id == def_id).first()
    if not defn:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    try:
        require_lock(db, defn.project_id, "vulnerability_definition", def_id, current_user)
    except PermissionError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    existing = {i.host_id for i in db.query(VulnerabilityInstance).filter(
        VulnerabilityInstance.vulnerability_definition_id == def_id
    ).all()}
    target = set(body.host_ids)
    to_add = target - existing
    to_remove = existing - target
    for hid in to_add:
        h = db.query(Host).filter(Host.id == hid, Host.project_id == defn.project_id).first()
        if h:
            db.add(VulnerabilityInstance(
                project_id=defn.project_id,
                vulnerability_definition_id=def_id,
                host_id=hid,
            ))
            log_audit(db, project_id=defn.project_id, user_id=current_user.id,
                      action_type="host_added_to_vulnerability",
                      record_type="vulnerability_definition", record_id=def_id,
                      after_json={"host_id": str(hid)})
    for hid in to_remove:
        db.query(VulnerabilityInstance).filter(
            VulnerabilityInstance.vulnerability_definition_id == def_id,
            VulnerabilityInstance.host_id == hid,
        ).delete()
        log_audit(db, project_id=defn.project_id, user_id=current_user.id,
                  action_type="host_removed_from_vulnerability",
                  record_type="vulnerability_definition", record_id=def_id,
                  before_json={"host_id": str(hid)})
    db.commit()
    db.refresh(defn)
    return _vuln_def_to_response(db, defn)


@router.patch("/{def_id}/affected-subnets", response_model=VulnerabilityDefinitionWithInstances)
def update_affected_subnets(
    def_id: UUID,
    body: AffectedSubnetsUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    defn = db.query(VulnerabilityDefinition).filter(VulnerabilityDefinition.id == def_id).first()
    if not defn:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    try:
        require_lock(db, defn.project_id, "vulnerability_definition", def_id, current_user)
    except PermissionError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    db.query(VulnerabilitySubnetAssociation).filter(
        VulnerabilitySubnetAssociation.vulnerability_definition_id == def_id
    ).delete()
    for sid in body.subnet_ids:
        sub = db.query(Subnet).filter(Subnet.id == sid, Subnet.project_id == defn.project_id).first()
        if sub:
            db.add(VulnerabilitySubnetAssociation(
                vulnerability_definition_id=def_id,
                subnet_id=sid,
            ))
            log_audit(db, project_id=defn.project_id, user_id=current_user.id,
                      action_type="vulnerability_applied_to_subnet",
                      record_type="vulnerability_definition", record_id=def_id,
                      after_json={"subnet_id": str(sid)})
    db.commit()
    db.refresh(defn)
    return _vuln_def_to_response(db, defn)


@router.get("/{def_id}/attachments", response_model=list[VulnerabilityAttachmentRead])
def list_vulnerability_attachments(
    def_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    defn = db.query(VulnerabilityDefinition).filter(VulnerabilityDefinition.id == def_id).first()
    if not defn:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    atts = db.query(VulnerabilityAttachment).options(
        joinedload(VulnerabilityAttachment.uploaded_by)
    ).filter(VulnerabilityAttachment.vulnerability_definition_id == def_id).order_by(
        VulnerabilityAttachment.created_at.asc()
    ).all()
    return [
        VulnerabilityAttachmentRead(
            id=a.id,
            vulnerability_definition_id=a.vulnerability_definition_id,
            filename=a.filename,
            mime=a.mime,
            size=a.size,
            is_pasted=bool(a.is_pasted),
            uploaded_by_username=a.uploaded_by.username if a.uploaded_by else None,
            created_at=a.created_at,
        )
        for a in atts
    ]


@router.post("/{def_id}/attachments", response_model=VulnerabilityAttachmentRead, status_code=201)
def upload_vulnerability_attachment(
    def_id: UUID,
    file: UploadFile = File(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    defn = db.query(VulnerabilityDefinition).filter(VulnerabilityDefinition.id == def_id).first()
    if not defn:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    try:
        require_lock(db, defn.project_id, "vulnerability_definition", def_id, current_user)
    except PermissionError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    base = os.path.join(settings.attachments_dir, "vuln_def", str(def_id))
    os.makedirs(base, exist_ok=True)
    ext = os.path.splitext(file.filename or "file")[1] or ""
    fname = f"{uuid_mod.uuid4().hex}{ext}"
    path = os.path.join(base, fname)
    with open(path, "wb") as f:
        shutil.copyfileobj(file.file, f)
    size = os.path.getsize(path)
    att = VulnerabilityAttachment(
        vulnerability_definition_id=def_id,
        filename=file.filename or "uploaded",
        mime=file.content_type,
        size=size,
        stored_path=path,
        uploaded_by_user_id=current_user.id,
        is_pasted=False,
    )
    db.add(att)
    log_audit(db, project_id=defn.project_id, user_id=current_user.id,
              action_type="vulnerability_attachment_uploaded",
              record_type="vulnerability_definition", record_id=def_id,
              after_json={"attachment_id": str(att.id), "filename": att.filename})
    db.commit()
    db.refresh(att)
    att.uploaded_by_username = current_user.username
    return VulnerabilityAttachmentRead(
        id=att.id,
        vulnerability_definition_id=att.vulnerability_definition_id,
        filename=att.filename,
        mime=att.mime,
        size=att.size,
        is_pasted=False,
        uploaded_by_username=current_user.username,
        created_at=att.created_at,
    )


@router.post("/{def_id}/attachments/paste", response_model=VulnerabilityAttachmentRead, status_code=201)
def paste_vulnerability_screenshot(
    def_id: UUID,
    file: UploadFile = File(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Accept pasted screenshot (multipart with image data)."""
    defn = db.query(VulnerabilityDefinition).filter(VulnerabilityDefinition.id == def_id).first()
    if not defn:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    try:
        require_lock(db, defn.project_id, "vulnerability_definition", def_id, current_user)
    except PermissionError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    base = os.path.join(settings.attachments_dir, "vuln_def", str(def_id))
    os.makedirs(base, exist_ok=True)
    ext = ".png"
    fname = f"{uuid_mod.uuid4().hex}{ext}"
    path = os.path.join(base, fname)
    with open(path, "wb") as f:
        shutil.copyfileobj(file.file, f)
    size = os.path.getsize(path)
    att = VulnerabilityAttachment(
        vulnerability_definition_id=def_id,
        filename="Pasted Screenshot",
        mime=file.content_type or "image/png",
        size=size,
        stored_path=path,
        uploaded_by_user_id=current_user.id,
        is_pasted=True,
    )
    db.add(att)
    log_audit(db, project_id=defn.project_id, user_id=current_user.id,
              action_type="vulnerability_screenshot_pasted",
              record_type="vulnerability_definition", record_id=def_id,
              after_json={"attachment_id": str(att.id)})
    db.commit()
    db.refresh(att)
    return VulnerabilityAttachmentRead(
        id=att.id,
        vulnerability_definition_id=att.vulnerability_definition_id,
        filename="Pasted Screenshot",
        mime=att.mime,
        size=att.size,
        is_pasted=True,
        uploaded_by_username=current_user.username,
        created_at=att.created_at,
    )


@router.get("/{def_id}/attachments/{att_id}")
def get_vulnerability_attachment_file(
    def_id: UUID,
    att_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    from fastapi.responses import FileResponse
    att = db.query(VulnerabilityAttachment).filter(
        VulnerabilityAttachment.id == att_id,
        VulnerabilityAttachment.vulnerability_definition_id == def_id,
    ).first()
    if not att or not os.path.isfile(att.stored_path):
        raise HTTPException(status_code=404, detail="Attachment not found")
    return FileResponse(att.stored_path, filename=att.filename, media_type=att.mime or "application/octet-stream")


@router.delete("/{def_id}/attachments/{att_id}", status_code=204)
def delete_vulnerability_attachment(
    def_id: UUID,
    att_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    defn = db.query(VulnerabilityDefinition).filter(VulnerabilityDefinition.id == def_id).first()
    if not defn:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    try:
        require_lock(db, defn.project_id, "vulnerability_definition", def_id, current_user)
    except PermissionError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    att = db.query(VulnerabilityAttachment).filter(
        VulnerabilityAttachment.id == att_id,
        VulnerabilityAttachment.vulnerability_definition_id == def_id,
    ).first()
    if not att:
        raise HTTPException(status_code=404, detail="Attachment not found")
    if os.path.isfile(att.stored_path):
        os.remove(att.stored_path)
    db.delete(att)
    db.commit()
    return None


@router.delete("/{def_id}", status_code=204)
def delete_vulnerability_definition(
    def_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    defn = db.query(VulnerabilityDefinition).filter(VulnerabilityDefinition.id == def_id).first()
    if not defn:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    try:
        require_lock(db, defn.project_id, "vulnerability_definition", def_id, current_user)
    except PermissionError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    db.delete(defn)
    db.commit()
    return None
